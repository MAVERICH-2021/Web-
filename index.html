<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
	<meta charset="utf-8">
	<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
	<meta name="viewport" content="width=device-width user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
	<title>减法合成器入门教程</title>
	<link href="css_menu_start.css" rel="stylesheet" />

</head>

<body data-new-gr-c-s-check-loaded="14.1018.0" data-gr-ext-installed="">
	<h1>目录</h1>
	<div class="win-grid">
		
			<div class="win-btn" id="1">1.声音的物理本质</div>
		
	<a href="Chapter2/Chapter2.html">
		<div class="win-btn" id="2">2.声音的物理描述</div>
		</a>
		<div class="win-btn" id="3">3.傅里叶信号变换</div>
		<a href="Chapter4/Chapter4.html">
			<div class="win-btn" id="4">4.基本波形的听觉特性</div>
		</a>
	
		<div class="win-btn" id="5">5.波形的合成与分解</div>
		<div class="win-btn" id="6">6.由下至上先做加法</div>
		<div class="win-btn" id="7">7.由上至下再做减法</div>
		<div class="win-btn" id="8">8.给音色增加动态</div>
		<div class="win-btn" id="9">9.实战关卡</div>
	</div>
	<script type="text/javascript" src="js/three.min.js"></script>
	<script type="text/javascript">
		var SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;

		var container;
		var camera, scene, renderer;

		var particles, particle, count = 0;

		var mouseX = 0, mouseY = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		init();
		animate();

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.z = 1000;

			scene = new THREE.Scene();

			particles = new Array();

			var PI2 = Math.PI * 2;
			var material = new THREE.ParticleCanvasMaterial({

				color: 0xffffff,
				program: function (context) {

					context.beginPath();
					context.arc(0, 0, 1, 0, PI2, true);
					context.fill();

				}

			});

			var i = 0;

			for (var ix = 0; ix < AMOUNTX; ix++) {

				for (var iy = 0; iy < AMOUNTY; iy++) {

					particle = particles[i++] = new THREE.Particle(material);
					particle.position.x = ix * SEPARATION - ((AMOUNTX * SEPARATION) / 2);
					particle.position.z = iy * SEPARATION - ((AMOUNTY * SEPARATION) / 2);
					scene.add(particle);

				}

			}

			renderer = new THREE.CanvasRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			document.addEventListener('mousemove', onDocumentMouseMove, false);
			document.addEventListener('touchstart', onDocumentTouchStart, false);
			document.addEventListener('touchmove', onDocumentTouchMove, false);

			//

			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		//

		function onDocumentMouseMove(event) {

			mouseX = event.clientX - windowHalfX;
			mouseY = event.clientY - windowHalfY;

		}

		function onDocumentTouchStart(event) {

			if (event.touches.length === 1) {

				event.preventDefault();

				mouseX = event.touches[0].pageX - windowHalfX;
				mouseY = event.touches[0].pageY - windowHalfY;

			}

		}

		function onDocumentTouchMove(event) {

			if (event.touches.length === 1) {

				event.preventDefault();

				mouseX = event.touches[0].pageX - windowHalfX;
				mouseY = event.touches[0].pageY - windowHalfY;

			}

		}

		//

		function animate() {

			requestAnimationFrame(animate);

			render();


		}

		function render() {

			camera.position.x += (mouseX - camera.position.x) * .05;
			camera.position.y += (- mouseY - camera.position.y) * .05;
			camera.lookAt(scene.position);

			var i = 0;

			for (var ix = 0; ix < AMOUNTX; ix++) {

				for (var iy = 0; iy < AMOUNTY; iy++) {

					particle = particles[i++];
					particle.position.y = (Math.sin((ix + count) * 0.3) * 50) + (Math.sin((iy + count) * 0.5) * 50);
					particle.scale.x = particle.scale.y = (Math.sin((ix + count) * 0.3) + 1) * 2 + (Math.sin((iy + count) * 0.5) + 1) * 2;

				}

			}

			renderer.render(scene, camera);

			count += 0.1;

		}
	</script>
	<div><canvas width="833" height="919" style="width: 833px; height: 919px;"></canvas></div>


</body>

</html>
<script src="script_menu_start.js"></script>